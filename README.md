# item_simul

[소개]
간단한 계정 확인을 통해 게임 속 캐릭터의 여러 가지 상태를 웹 상에서 확인하는 프로젝트입니다!

[구조]
5가지의 라우터와 2가지의 미들웨어를 통해 서빙을 구현했습니다!

1. 라우터

- 계정 관련 라우터 : 회원가입과 로그인을 담당하는 api들
- 캐릭터 관련 라우터 : 캐릭터의 생성, 삭제 및 상세 조회와 게임 머니 벌기를 담당하는 api들
- 아이템 관련 라우터 : 아이템의 생성, 삭제, 목록 조회 및 상세 조회를 담당하는 api들
- 거래 관련 라우터 : 아이템의 구매 및 판매를 담당하는 api들
- 소지품 및 장비 관련 라우터 : 아이템 장착, 탈착, 소지품 조회 및 장비 조회를 담당하는 api들

2. 미들웨어

- 인증 미들웨어 : 계정 확인이 필요한 api들의 실행 전 거침
- 에러 알림 미들웨어 : 예외 처리가 되지 않은 오류 발생 시 이를 알려줌 (모든 api에 적용)

[DB테이블구성]
"기본 키와 관련된 컬럼들은 기입하지 않았습니다!!"

1. 계정 정보 테이블 Accounts

- 아이디 / 비밀번호 / 사용자 이름 / 가입일자
- accountKey 컬럼을 기준으로 Characters 테이블과 1:N 관계

2. 캐릭터 정보 테이블 Characters

- 캐릭터 이름 / 능력치 / 보유재화 / 생성일자
- charKey 컬럼을 기준으로 Inventory 테이블과 1:N 관계
- charKey 컬럼을 기준으로 Equips 테이블과 1:N 관계

3. 아이템 정보 테이블 Items

- 아이템 코드 / 아이템 이름 / 부여 능력치 / 가격 / 추가일자 / 수정일자
- itemKey 컬럼을 기준으로 Inventory 테이블과 1:N 관계
- itemKey 컬럼을 기준으로 Equips 테이블과 1:N 관계

4. 소지품 정보 테이블 Inventory

- 아이템 코드 / 아이템 이름 / 수량

5. 장착 아이템 정보 테이블 Equips

- 아이템 코드 / 아이템 이름

[질문과답변]

1. 암호화 방식

- 비밀번호를 DB에 저장할 때 Hash를 이용했는데, Hash는 단방향 암호화와 양방향 암호화 중 어떤 암호화 방식에 해당할까요?
  bycrypt.hash()의 결과로 반환되는 암호화된 문자열은 기존의 데이터로 복구할 수 없기 때문에, 단방향 암호화에 해당합니다!!
- 비밀번호를 그냥 저장하지 않고 Hash 한 값을 저장 했을 때의 좋은 점은 무엇인가요?
  입력받은 비밀번호와 Hash한 값을 비교 검증하는 건 가능하기 때문에 인증 또는 인가 등의 필요한 기능에 활용할 수 있습니다.
  동시에 제 3자가 Hash한 값을 획득하더라도, 추가 정보 없이는 기존 데이터로 복구하는 것이 불가능하기 때문에,
  비교적 안정적인 정보 보호가 가능합니다!

2. 인증 방식

- JWT(Json Web Token)을 이용해 인증 기능을 했는데, 만약 Access Token이 노출되었을 경우 발생할 수 있는 문제점은 무엇일까요?
  Access Token은 사용자 인증에 필요한 대부분의 정보를 지니고 있습니다. 또한 노출이 되었더라도, 서버에선 그 사실을 판별할 수 없습니다.
  제 3자가 토큰을 활용하더라도 아낌없이 문을 열어주게 되지만, 토큰의 문제 여부를 알 수 없으니 이를 만료시킬 지 판단도 할 수 없습니다!
- 해당 문제점을 보완하기 위한 방법으로는 어떤 것이 있을까요?
  Refresh Token을 활용해 노출 시 받을 피해를 최소화할 수 있습니다. 사용자가 Access Token을 가지고 있는 시간이 길어질수록,
  토큰엔 더 많은 기록과 정보가 담기게 됩니다. 따라서 토큰에 적절한 기한을 설정하고, 기한 만료시 토큰이 사라지도록 구현해
  예상되는 피해를 줄일 수 있게 됩니다. Refresh Token은 기존 토큰이 만료됐을 시 추가로 요청해 받는 토큰의 개념으로,
  Access Token과는 다르게 서버에서 강제로 토큰을 만료시킬 수 있습니다. 사용자의 인증 상태를 서버에서 관리할 수 있게 됨으로써,
  토큰 노출로 인한 피해에 보다 신속히 대응할 수 있습니다!

3. 인증과 인가

- 인증과 인가가 무엇인지 각각 설명해 주세요.
  인증은, 서비스에 접근하는 단계에서 이 사용자가 서비스를 이용할 자격을 갖췄는지 확인하는 절차를 의미합니다.
  ZEP 공간에 들어오기 위해 사용자 로그인을 해야하는 이유가 바로 인증을 위함입니다.
  인가는, 이미 인증된 사용자가 서비스의 특정 기능에 접근하거나, 이를 사용할 권한이 있는지를 판단하는 단계입니다.
  ZEP 공간에서 맵이나 공지를 수정하는 등의 작업을 위해선 관리자 계정이 필요한 이유가 바로 인가 때문입니다!
- 위 API 구현 명세에서 인증을 필요로 하는 API와 그렇지 않은 API의 차이가 뭐라고 생각하시나요?
  "남의 것"을 훼손하지 않도록 방지하기 위한 의도가 있다고 생각합니다. 게임은 사용자의 시간과 노력을 들여 경험을 쌓는 일이라고 생각합니다.
  그런데 누군가 임의로 자신의 경험을 훼손하고 무너뜨린다면, 사용자 입장에서 불쾌한 기억이 될 것입니다.
  설계자는 이를 예방할 필요가 있기 때문에, 캐릭터의 무언가를 조작할 수 있는 기능이라면, 인증을 필요로 하도록 구현해야합니다!
- 아이템 생성, 수정 API는 인증을 필요로 하지 않는다고 했지만 사실은 어느 API보다도 인증이 필요한 API입니다. 왜 그럴까요?
  현 프로젝트에서 두 API는 악용될 여지가 큽니다. 아이템 테이블은 게임에 존재하는 아이템들을 도감처럼 모아놓은 저장소입니다.
  안정적인 UX를 보장하기 위해선, 아이템들의 성능이 제작자의 설계에 맞게 발휘돼야 합니다.
  만약 누구나 아이템 현황을 조정할 수 있다면, 임의로 오버 파워의 아이템을 만들어내거나, 버그성 아이템을 구현하는 등,
  게임 내 밸런스에 악영향을 미칠 수 있습니다. 따라서 두 API는 관리자 또는 제작자 권한의 인가 절차가 필수적입니다!

4. HTTP 상태 코드

- 과제를 진행하면서 사용한 Http Status Code를 모두 나열하고, 각각이 의미하는 것과 어떤 상황에 사용했는지 작성해 주세요.
  200 : 요청이 성공했음을 알림 (로그인 성공, 아이템 생성 성공 등의 응답에 활용!)
  201 : 일반적으로 POST 요청에 대해, 리소스 생성이 성공했음을 알림 (회원가입 성공, 아이템 거래 및 장착 성공 등의 응답에 활용!)
  400 : 입력받은 데이터 형식이 잘못된 경우 등, 서버가 요청을 이해할 수 없음을 알림 (입력 데이터가 요구 양식에 어긋난 경우 활용!)
  401 : 인증되지 않은 상태에서 인증이 필요한 기능에 접근했음을 알림 (로그인 시 아이디 및 비밀번호 입력 오류 알림에 활용!)
  403 : 인증은 됐지만 권한이 없는 상태에서, 권한이 필요한 기능에 접근했음을 알림 (타인 캐릭터 조작 시도 시 활용!)
  404 : 요청한 리소스나 경로가 존재하지 않음을 알림 (존재하지 않는 캐릭터나 아이템 등에 접근 시도 시 활용!)
  409 : 요청이 현재 서버의 상태와 충돌함을 알림 (이미 존재하는 아이디나 캐릭터명 생성 시도 시 활용!)

5. 게임 경제

- 캐릭터 테이블에 money라는 게임 머니 컬럼만 추가하였을 때 어떠한 단점이 있을 수 있을까요?
  만약 캐릭터의 접근 권한이 조작되거나 변질되어 A 캐릭터가 A의 모든 데이터를 관리할 수 있게 된다면 문제가 발생합니다.
  임의의 캐릭터가 보유 재화를 마음대로 조정할 수 있게 됨으로써, 인게임 경제를 불안정하게 만들 수 있습니다.
- 다르게 구현할 수 있는 방법은 어떤 것이 있을까요?
  캐릭터별 보유 재화량과 습득 및 지불 내역을 관리하는 테이블을 별개로 만들고, 이를 관리자 인가를 통해 별도 관리하는 방법이 있습니다.
  재화의 정확한 출처를 확인해 문제 발생 시 원인 파악이 수월할 것이며, 각 캐릭터의 경제 개입 정도를 줄여,
  예기치 못한 타격이 생기는 일을 어느 정도 방지할 수 있습니다!
- 아이템 구입 시에 가격을 클라이언트에서 입력하게 하면 어떠한 문제점이 있을 수 있을까요?
  마찬가지로, 설계된 정가와 달리 임의의 가격으로 거래가 이뤄짐으로써, 관리자가 의도한 경제 흐름을 수호할 수 없게 됩니다.

6. 어려웠던 점
   다양한 라이브러리를 한 번에 학습하고 한 번에 실습하려다 보니, 과제 이해도가 모자란 느낌이 들었습니다.
   특히 다양한 메서드를 활용하는 과정에서, 각 메서드의 정확한 기능을 파악하지 못한 채 사용하게 된 상황이 아쉬웠습니다.
   물론 시간 제약이 있는 상황이었기에 불가피했지만, 이로 인한 오류들 (특히 prisma.$transaction)을 처리하느라
   시간 소모가 큰 탓에, 구상한 기능들을 전부 구현하지 못 한 아쉬움이 남습니다.
   이어지는 아쉬움으로, 응용이 필요한 상황에서 많이 약해지는 느낌을 받았습니다. 스켈레톤 코드는 없었지만,
   강의에서 진행한 실습 코드들을 기반으로 수정이 가능한 상황이었는데, 이를 본인의 코드로 최적화하는 과정이 어려웠습니다.
   특히 변수나 데이터베이스 관리 등, 구현할 API들과 상호작용이 돼야하는 설계 부분에서,
   실수가 잦아 이를 수정하고 초기화하는 과정에 또 시간을 많이 쓴 점이 아쉽습니다.
   오류 해결 과정은 분명한 공부가 되는 고난이기에 그래도 환영인데, 데이터베이스 초기화 및 재생은 정말 단순 노동인지라 달갑지 않았습니다...
   그래도 손에 잡히지 않을 것만 같던 생소한 내용을 어느 정도 습득하고, 이번 과제를 통해 큰 틀을 익히게 된 것 같아 뿌듯합니다.
   뿌리를 잘 내렸으니, 앞으론 가지를 쭉쭉 뻗어 풍성한 지식을 축적하도록 하겠습니다~!
